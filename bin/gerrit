#!/usr/bin/env node
"use strict";

var program = require("commander");
var domain = require("domain").create();
var Q = require("bluebird");
var chalk = require("chalk");
var _ = require("lodash");

var cli = require("../lib/cli");
var git = require("../lib/git");
var gerrit = require("../lib/gerrit");
var logger = require("../lib/logger");


/** Define Interface **/

program.command("help")
  .action(program.help.bind(program));

program.command("config [config_name]")
  .description("Create a server configuration for the given config name if it does not already exist, otherwise displays the configuration values. Include the `--edit` flag to edit an existing config. If no config name is provided then 'default' will be used.")
  .option("--all")
  .option("-e, --edit")
  .action(cli.config);

program.command("projects [config_name]")
  .description("Display a list of projnamenameects for the given gerrit-cli config. If no config name is provided then 'default' will be used.")
  .action(cli.projects);

program.command("clone [config_name] [project_name] [destination_folder]")
  .description("Clones a project from the Gerrit server and installs the commit-msg hook. To let gerrit-cli prompt you with the available configs and projects don't provide any arguments.")
  .action(cli.clone);

program.command("status")
  .alias("st")
  .option("--author <name>").option("--not-author <name>")
  .option("--owner <name>").option("--not-owner <name>")
  .option("--reviewer <name>").option("--not-reviewer <name>")
  .option("--branch <name>").option("--not-branch <name>")
  .option("--topic <name>").option("--not-topic <name>")
  .option("--message <messagew>").option("--not-message <message>")
  .option("--age <age>").option("--not-age <age>")
  .option("--drafts").option("--not-drafts")
  .option("--starred").option("--not-starred")
  .option("--watched").option("--not-watched")
  .option("--reviewed").option("--not-reviewed")
  .option("--assigned").option("--not-assigned")
  .option("--mine").option("--not-mine")
  .option("-r, --remote <remote>")
  .option("--table")
  .option("--oneline")
  .option("--format <format>")
  .action(cli.status);

program.command("assign")
  .option("-a, --all")
  .option("-i, --interactive")
  .option("-r, --remote <remote>")
  .action(function() {
    var reviewers = program.args.slice(0, -1);
    var options = arguments[arguments.length-1];
    cli.assign(reviewers, options);
  });

program.command("push [base_branch]")
  .option("-r, --remote <remote>")
  .option("--assign [reviewer...]")
  .action(function(base_branch, options) {
    push_action("push", base_branch, options);
  });

program.command("draft [base_branch]")
  .option("-r, --remote <remote>")
  .option("--assign [reviewer...]")
  .action(function(base_branch, options) {
    push_action("draft", base_branch, options);
  });

function push_action(command_name, base_branch, options) {
  var reviewers = [];
  var is_draft = (command_name === "draft");
  var indexOfAssignFlag = program.rawArgs.indexOf("--assign");
  if (indexOfAssignFlag !== -1) {
    reviewers = program.rawArgs.slice(indexOfAssignFlag + 1);
    base_branch = program.rawArgs[indexOfAssignFlag - 1];
    if (base_branch === command_name) {
      base_branch = undefined;
    }
  }
  cli.push(base_branch, reviewers, is_draft, options);
}

program.command("checkout <change_id|topic> [patch_set]")
  .alias("co")
  .option("-r, --remote <remote>")
  .action(cli.checkout);

program.command("recheckout")
  .alias("reco")
  .option("-r, --remote <remote>")
  .action(cli.recheckout);

program.command("ssh <command>")
  .option("-r, --remote <remote>")
  .action(cli.ssh);

program.command("review [verified_score] [code_review_score] [message]")
  .option("-i, --interactive")
  .option("-r, --remote [remote]")
  .option("-1").option("-2") // capture these here so commander doesn't fail
  .action(function() {
    var options = arguments[arguments.length-1];
    var args = program.rawArgs.slice(program.rawArgs.indexOf("review") + 1);

    options.options.forEach(function(opt) {
      if (_.contains(["-2", "-1"], opt.long)) {
        return;
      }
      var flagIndex = args.indexOf(opt.short);
      if (flagIndex === -1) {
        flagIndex = args.indexOf(opt.long);
      }

      if (flagIndex !== -1) {
        var numSplice = 1;
        var value = options[opt.long.substr(2)];
        if (opt.required || (opt.optional && !_.isBoolean(value))) {
          numSplice = 2;
        }
        args.splice(flagIndex, numSplice);
      }
    });

    while (args.length < 3) {
      args.push(null);
    }

    args.push(options);

    cli.review.apply(null, args);
  });

program.command("submit [message]")
  .option("-a, --all")
  .option("-r, --remote <remote>")
  .action(cli.submit);

program.command("abandon [message]")
  .option("-a, --all")
  .option("-r, --remote <remote>")
  .action(cli.abandon);

program.command("comment [message]")
  .option("-a, --all")
  .option("-i, --interactive")
  .option("-r, --remote <remote>")
  .action(cli.comment);

program.command("pubmit [base_branch]")
  .alias("ninja")
  .option("-a, --all")
  .option("-r, --remote <remote>")
  .action(cli.pubmit);

program.command("browse")
  .alias("browser")
  .alias("bro")
  .option("-r, --remote <remote>")
  .action(cli.browse);

program.command("completion")
  .action(cli.completion);


/* Logging and Error Handling **/

logger.on("info", logProcess(function(line) {
  console.log(line);
}));

logger.on("warn", logProcess(function(line) {
  console.warn("gerrit " + chalk.yellow("WARN") + " " + line);
}));

logger.on("error", logProcess(function(line) {
  console.error("gerrit " + chalk.red("ERROR") + " " + line);
}));

function logProcess(lineOutputCallback) {
  return function(message, context) {
    message = message.split("\n");
    if (context) {
      for (var key in context) {
        var value = context[key];
        if (typeof value === "object") {
          value = JSON.stringify(value);
        }
        message.push("  " + chalk.magenta(key + ":") + " " + value);
      }
    }
    message.forEach(lineOutputCallback);
  };
}

Q.onPossiblyUnhandledRejection(function(e, promise) {
  throw e;
});

// handles exceptions, better than try/catch
// since it'll also handle those thrown from
// assynchronous calls
domain.on("error", function(err) {
  if (err instanceof git.GitError) {
    logger.error("There was an error running a git command", {
      command: err.command,
      output: err.message,
      code: err.code
    });
  }
  else if (err instanceof gerrit.GerritError) {
    logger.error(err.message);
    logger.error(err.stack.substr(err.stack.indexOf("\n") + 1));
  }
  else if (err instanceof cli.CliError) {
    logger.error(err.message);
  }
  else {
    logger.error(chalk.bgRed("UNKNOWN") + " " + err.toString(), err);
    logger.error(err.stack.substr(err.stack.indexOf("\n") + 1));
  }
});


/** Run it! **/

domain.run(function() {
  program.parse(process.argv);
});


